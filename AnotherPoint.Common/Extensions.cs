using System;
using System.Globalization;
using System.Reflection;
using System.Text;

namespace AnotherPoint.Common
{
	public static class Extensions
	{
		public static string FirstLetterToLower(this string str)
		{
			if (!char.IsLetter(str[0]))
			{
				return str;
			}

			StringBuilder sb = new StringBuilder(str.Length);
			sb.Append(str);
			sb[0] = char.ToLower(sb[0], CultureInfo.CurrentCulture);

			return sb.ToString();
		}

		public static string FirstLetterToUpper(this string str)
		{
			if (!char.IsLetter(str[0]))
			{
				return str;
			}

			StringBuilder sb = new StringBuilder(str.Length);
			sb.Append(str);
			sb[0] = char.ToUpper(sb[0], CultureInfo.CurrentCulture);

			return sb.ToString();
		}

		public static bool IsAutogenerated(this FieldInfo fieldInfo)
							=> fieldInfo.Name.Contains(Constant.BackgroundEntityMark);

		#region ConstructorInfo

		public static bool IsInternal(this ConstructorInfo constructorInfo)
			=> constructorInfo.IsAssembly;

		public static bool IsProtected(this ConstructorInfo constructorInfo)
			=> constructorInfo.IsFamily;

		public static bool IsProtectedInternal(this ConstructorInfo constructorInfo)
			=> constructorInfo.IsFamilyOrAssembly;

		#endregion ConstructorInfo

		#region FieldInfo

		public static bool IsInternal(this FieldInfo fieldInfo)
			=> fieldInfo.IsAssembly;

		public static bool IsProtected(this FieldInfo fieldInfo)
			=> fieldInfo.IsFamily;

		public static bool IsProtectedInternal(this FieldInfo fieldInfo)
			=> fieldInfo.IsFamilyOrAssembly;

		#endregion FieldInfo

		#region MethodInfo

		public static bool IsInternal(this MethodInfo methodInfo)
			=> methodInfo.IsAssembly;

		public static bool IsProtected(this MethodInfo methodInfo)
			=> methodInfo.IsFamily;

		public static bool IsProtectedInternal(this MethodInfo methodInfo)
			=> methodInfo.IsFamilyOrAssembly;

		#endregion MethodInfo

		#region Type

		public static bool IsInternal(this Type type)
			=> !type.IsPublic && !type.IsPrivate();

		public static bool IsPrivate(this Type type)
					=> type.IsNotPublic && type.IsNested;

		#endregion Type
	}
}