using AnotherPoint.Common;
using AnotherPoint.Entities;
using AnotherPoint.Extensions;
using System;
using System.Linq;
using System.Reflection;
using System.Text;

namespace AnotherPoint.Core
{
	public static class ClassCore
	{
		public static Class Map(Type type)
		{
			if (type.IsInterface)
			{
				throw new ArgumentException($"Type {type.FullName} is an interface");
			}

			Class @class = new Class(type.FullName)
			{
				AccessModifyer = ClassCore.GetAccessModifyer(type),
			};

			foreach (var classImplAttribute in type.GetCustomAttributes<ClassImplAttribute>())
			{
				if (classImplAttribute.IsEndPoint)
				{
					@class.IsEndpoint = true;
					@class.DestinationTypeName = classImplAttribute.DestinationTypeName;

				}
			}

			ClassCore.SetupGeneric(type, @class);

			ClassCore.SetupFields(type, @class);
			ClassCore.SetupProperties(type, @class);
			ClassCore.SetupCtors(type, @class);
			SetupInterfaces(type, @class);
			SetupMethods(type, @class);

			return @class;
		}

		private static void SetupMethods(Type type, Class @class)
		{
			foreach (var methodInfo in type.GetMethods(Constant.AllInstance | BindingFlags.DeclaredOnly)
											.Where(m => !m.Name.StartsWith(Constant.Get) && !m.Name.StartsWith(Constant.Set)))
			{
				Method method = MethodCore.Map(methodInfo, type.Name);

				@class.Methods.Add(method);
			}
		}

		private static void SetupInterfaces(Type type, Class @class)
		{
			foreach (var interfaceType in type.GetInterfaces())
			{
				Interface @interface = InterfaceCore.Map(interfaceType);

				@class.Interfaces.Add(@interface);
			}
		}

		public static string GetInterfacesAsString(Class @class)
		{
			StringBuilder sb = new StringBuilder(string.Join(",", @class.Interfaces.Select(i => i.FullName)));

			if (sb.Length > 0)
			{
				sb.Insert(0, " : ");
			}

			return sb.ToString();
		}

		private static AccessModifyer GetAccessModifyer(Type type)
		{
			AccessModifyer accessModifyer = AccessModifyer.None;

			if (type.IsPublic)
			{
				accessModifyer |= AccessModifyer.Public;
			}

			if (type.IsInternal())
			{
				accessModifyer |= AccessModifyer.Internal;
			}

			if (type.IsPrivate())
			{
				accessModifyer |= AccessModifyer.Private;
			}

			////////

			if (type.IsAbstract)
			{
				accessModifyer |= AccessModifyer.Abstract;
			}

			if (type.IsSealed)
			{
				accessModifyer |= AccessModifyer.Sealed;
			}

			return accessModifyer;
		}

		private static void SetupCtors(Type type, Class @class)
		{
			foreach (var constructorInfo in type.GetConstructors(Constant.AllInstance))
			{
				@class.Ctors.Add(CtorCore.Map(constructorInfo));
			}

			if (@class.Ctors.Count == 1 && 
					@class.Ctors.First().IsDefaultCtor())
			{
				@class.Ctors.Clear();
			}

			// I dont want class have default ctor next to ctor for dependency inject, so if there's only two of them - I remove default one
			if (@class.Ctors.Count == 2)
			{
				Ctor defaultCtor = @class.Ctors.FirstOrDefault(c => c.IsDefaultCtor());
				Ctor injectCtor = @class.Ctors.FirstOrDefault(c => c.IsCtorForInject);

				if (defaultCtor != null && injectCtor != null)
				{
					@class.Ctors.Remove(defaultCtor);
				}
			}
		}

		private static void SetupFields(Type type, Class @class)
		{
			foreach (var fieldInfo in type.GetFields(Constant.AllInstance)
														.Where(f => !f.IsAutogenerated()))
			{
				@class.Fields.Add(FieldCore.Map(fieldInfo));
			}

			if (@class.IsEndpoint)
			{
				Field destinationField = new Field(GetDefaultDestinationName(@class), @class.DestinationTypeName)
				{
					AccessModifyer = AccessModifyer.Private
				};

				destinationField.Name = destinationField.Name.FirstLetterToLower();

				@class.Fields.Add(destinationField);

				Ctor injectedCtor = new Ctor(@class.Type.FullName);

				injectedCtor.AccessModifyer = AccessModifyer.Public;
				injectedCtor.IsCtorForInject = true;

				Argument arg = new Argument(destinationField.Name.FirstLetterToLower(), 
												destinationField.Type.FullName,
												BindSettings.Exact);

				injectedCtor.ArgumentCollection.Add(arg);

				@class.Ctors.Add(injectedCtor);
			}
		}

		public static string GetDefaultDestinationName(Class @class)
		{
			return $"{@class.Name}Destination";
		}

		private static void SetupGeneric(Type type, Class @class)
		{
			@class.Type.IsGeneric = type.IsGenericType;

			foreach (var genericTypeArgument in type.GenericTypeArguments)
			{
				@class.Type.GenericTypes.Add(genericTypeArgument.FullName);
			}
		}

		private static void SetupProperties(Type type, Class @class)
		{
			foreach (var propertyInfo in type.GetProperties(Constant.AllInstance))
			{
				@class.Properties.Add(PropertyCore.Map(propertyInfo));
			}
		}
	}
}